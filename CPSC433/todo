1. Generation of our inital set of solutions
   -This will be done via a Or-Tree based search, which will attempt to generate valid, complete solutions without regard to the penalties of said solutions

2. Implement extension rules
   -Mutation should be fairly simple, given a solution, we select the single assignment contributing the most to the solution's penalty, and change it to something better
   -Crossover will be more difficult, as we need a way to split each solution into 2 parts and combine them into another valid solution, hopefully with a better penalty

3. Implement kontrol
   -When applying the extension rules, I suspect we'll get the best bang for our buck if we apply multiple rules every generation via a simple Or-Tree search
   -We need to ensure that the queue of extension rules to try doesn't get unmanageably large

4. Optimizations
   -The lecture class really should maintain a count of the number of students enrolled in an instance, will make hard constraint checking much more efficient
   -Penalty calculation could probably be made much more efficient. At the moment we’re calculating each penalty on it’s own, we could probably combine at least a couple of them and remove a couple of tree traversals. Also, having a way to search for an assignment in a treeset would be handy and make things a lot more efficient.