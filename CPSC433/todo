1. Dealing with hard and soft contraints
   -We need a way of measuring the penalty associated with a given partial solution, as well as identify individual assignments or groups of assignments within this partial solution that are greatly increasing the penalty

2. Generation of our inital set of solutions
   -This will be done via a Or-Tree based search, which will attempt to generate valid, complete solutions without regard to the penalties of said solutions

3. Implement extension rules
   -Mutation should be fairly simple, given a solution, we select the single assignment contributing the most to the solution's penalty, and change it to something better
   -Crossover will be more difficult, as we need a way to split each solution into 2 parts and combine them into another valid solution, hopefully with a better penalty

4. Implement kontrol
   -When applying the extension rules, I suspect we'll get the best bang for our buck if we apply multiple rules every generation via a simple Or-Tree search
   -We need to ensure that the queue of extension rules to try doesn't get unmanageably large

5. Optimizations
   -The lecture class really should maintain a count of the number of students enrolled in an instance, will make hard constraint checking much more efficient
   -Penalty calculation could probably be made much more efficient, i.e. reduce unnecessary tree traversals. This would mean restructuring it a bit